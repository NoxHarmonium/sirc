\chapter{Shift Operations}
\label{ch:shift-operations}

\section{Overview}

The SIRC-1 CPU supports powerful shift operations that can be applied to operands in many instructions. Shifts can
multiply or divide values by powers of 2, extract bit fields, or perform bit rotations.

Shift operations are encoded within Short Immediate and Register format instructions, allowing a value to be shifted
before being used in an ALU operationâ€”all within a single instruction.

\textbf{Note:} By default, when shifts are used with ALU instructions (apart from the SHFT meta instruction), the status register flags are updated based on the ALU operation result, not the shift. However, you can manually control this behavior using the status override syntax (see Section~\ref{sec:status-override}).

\section{Shift Types}

\subsection{Shift Type Encoding}

\begin{table}[H]
	\centering
	\begin{tabular}{clcp{7cm}}
		\toprule
		\textbf{Code} & \textbf{Mnemonic} & \textbf{Type}          & \textbf{Description}             \\
		\midrule
		000           & --                & None                   & No shift performed               \\
		001           & LSL               & Logical Shift Left     & Shift left, fill with zeros      \\
		010           & LSR               & Logical Shift Right    & Shift right, fill with zeros     \\
		011           & ASL               & Arithmetic Shift Left  & Same as LSL (shifts in zeros)    \\
		100           & ASR               & Arithmetic Shift Right & Shift right, preserving sign bit \\
		101           & RTL               & Rotate Left            & Rotate left through carry        \\
		110           & RTR               & Rotate Right           & Rotate right through carry       \\
		111           & --                & Reserved               & Reserved for future use          \\
		\bottomrule
	\end{tabular}
	\caption{Shift Type Encoding}
	\label{tab:shift-encoding}
\end{table}

\section{Shift Syntax}

A shift postamble can come after any short immediate or register instruction. It is applied in the "Decode and Register
Fetch" phase of instruction execution, before any ALU operations or memory address calculation occurs.

It is applied to the first source operand of an instruction. If using the three operand form of instruction, it will be
the second operand. If using the two operand form of instruction, the second operand is inferred to be the same as the
destination.

See this table for some examples of which operand is shifted:

\begin{table}[H]
	\centering
	\begin{tabular}{lll}
		\toprule
		\textbf{Instruction}     & \textbf{How the CPU Interprets It} & \textbf{First Source Operand} \\
		\midrule
		ADDR r1, r2, r3, LSL \#1 & ADDR r1, r2, r3, LSL \#1           & r2                            \\
		ADDR r1, r2, LSL \#1     & ADDR r1, r1, r2, LSL \#1           & r1                            \\
		ADDI r1, \#2, LSL \#1    & ADDI r1, r1, \#2, LSL \#1          & r1                            \\
		\bottomrule
	\end{tabular}
	\caption{Examples of first source operands}
	\label{tab:source-operand-examples}
\end{table}

\section{Shift Type Details}

\subsection{Logical Shift Left (LSL)}

\textbf{Operation:} Shift bits to the left, filling vacated bits with zeros.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{17}
		\bitheader{0-15} \\
		\bitbox{1}{$\leftarrow$}
		\bitbox{15}{\small Shift Left}
		\bitbox{1}{0}
	\end{bytefield}
	\caption{Logical Shift Left}
\end{figure}

\begin{itemize}
	\item Bit 15 is shifted into the carry flag
	\item Bit 0 receives 0
	\item Equivalent to multiplying by $2^n$ where $n$ is the shift count
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Multiply r1 by 4
ADDI r1, #0, LSL #2  ; r1 = (r1 << 2) = r1 * 4

% TODO: This is broken
; Set bit 10
ORRI r3, #1, LSL #10     ; r3 |= (r3 << 10) with immediate 1 = 0x0400
\end{lstlisting}

\subsection{Logical Shift Right (LSR)}

\textbf{Operation:} Shift bits to the right, filling vacated bits with zeros.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{17}
		\bitheader{0-15} \\
		\bitbox{1}{0}
		\bitbox{15}{\small Shift Right}
		\bitbox{1}{$\rightarrow$}
	\end{bytefield}
	\caption{Logical Shift Right}
\end{figure}

\begin{itemize}
	\item Bit 0 is shifted into the carry flag
	\item Bit 15 receives 0
	\item Equivalent to unsigned division by $2^n$
	\item Use for unsigned values only
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Divide unsigned value by 8
ADDI r1, #0, LSR #3  ; r1 = (r1 >> 3) = r1 / 8 (unsigned)

; Extract upper byte
ADDI r3, #0, LSR #8  ; r3 = (r3 >> 8)
\end{lstlisting}

\subsection{Arithmetic Shift Left (ASL)}

\textbf{Operation:} Identical to LSL. Shift bits to the left, filling with zeros.

\begin{itemize}
	\item Equivalent to signed multiplication by $2^n$
	\item Can cause signed overflow if sign bit changes
	\item Overflow flag is set if sign bit changes during shift
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Multiply signed value by 2
ADDI r1, #0, ASL #1  ; r1 = (r1 << 1) = r1 * 2 (signed)
\end{lstlisting}

\subsection{Arithmetic Shift Right (ASR)}

\textbf{Operation:} Shift bits to the right, preserving the sign bit (bit 15).

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{17}
		\bitheader{0-15} \\
		\bitbox{1}{$\curvearrowleft$}
		\bitbox{15}{\small Shift Right}
		\bitbox{1}{$\rightarrow$}
	\end{bytefield}
	\caption{Arithmetic Shift Right}
\end{figure}

\begin{itemize}
	\item Bit 0 is shifted into the carry flag
	\item Bit 15 (sign bit) is copied into bit 15 and bit 14
	\item Equivalent to signed division by $2^n$ (rounds toward negative infinity)
	\item Use for signed values only
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Divide signed value by 4
ADDI r1, #0, ASR #2  ; r1 = (r1 >> 2) = r1 / 4 (signed)

; Average two signed values
ADDR r3, r4, r5
ADDI r3, #0, ASR #1  ; r3 = (r3 >> 1) = (r4 + r5) / 2
\end{lstlisting}

\subsection{Rotate Left (RTL)}

\textbf{Operation:} Rotate bits to the left through the carry flag.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{18}
		\bitbox{1}{C}
		\bitheader{0-15} \\
		\bitbox{1}{$\curvearrowleft$}
		\bitbox{1}{$\leftarrow$}
		\bitbox{15}{\small Rotate Left}
		\bitbox{1}{$\curvearrowleft$}
	\end{bytefield}
	\caption{Rotate Left}
\end{figure}

\begin{itemize}
	\item Bit 15 moves into the carry flag
	\item Previous carry flag value moves into bit 0
	\item No data is lost
	\item Useful for multi-word shifts and bit manipulation
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Rotate r1 left by 1
ADDI r1, #0, ROL #1

; Multi-word left shift (32-bit value in r1:r2)
ADDI r2, #0, LSL #1  ; Shift low word, bit 15 -> carry
ADDI r1, #0, RTL #1  ; Shift high word, carry -> bit 0
\end{lstlisting}

\subsection{Rotate Right (RTR)}

\textbf{Operation:} Rotate bits to the right through the carry flag.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{18}
		\bitheader{0-15}
		\bitbox{1}{C} \\
		\bitbox{1}{$\curvearrowright$}
		\bitbox{15}{\small Rotate Right}
		\bitbox{1}{$\rightarrow$}
		\bitbox{1}{$\curvearrowright$}
	\end{bytefield}
	\caption{Rotate Right}
\end{figure}

\begin{itemize}
	\item Bit 0 moves into the carry flag
	\item Previous carry flag value moves into bit 15
	\item No data is lost
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Rotate r1 right by 1
ADDI r1, #0, RTR #1

; Check if bit 0 is set
ADDI r2, #0, RTR #1  ; Bit 0 -> carry
; Now branch on carry to test bit 0
\end{lstlisting}

\section{Shift Operands}

The Shift Operand (SO) bit determines what value is shifted:

\begin{table}[H]
	\centering
	\begin{tabular}{clp{8cm}}
		\toprule
		\textbf{SO Bit} & \textbf{Mode}           & \textbf{Description}                                     \\
		\midrule
		0               & Shift by Immediate      & R2 (first source operand) is shifted by a literal amount \\
		1               & Shift Count in Register & R2 is shifted by the amount in the shift count register  \\
		\bottomrule
	\end{tabular}
	\caption{Shift Operand Modes}
	\label{tab:shift-operand}
\end{table}

\subsection{Mode 0: Shift by Immediate}

The first source operand (R2) is shifted by a literal amount before the ALU operation.

\begin{lstlisting}
; Add (r1 * 4) + 1 to r1
ADDI r1, #1, LSL #2  ; r1 = r1 + (r2 << 2) + 1
                          ; SO=0: r2 is shifted by literal 2

\end{lstlisting}

\subsection{Mode 1: Shift by Register Count}

The shift count is taken from the shift amount field (interpreted as a register), allowing variable-length shifts. R2
(first source) is still what gets shifted.

\begin{lstlisting}
; Variable shift
; Shift amount register contains shift count
ADDR r1, r2, r3, LSL r4  ; r1 = (r2 << r4) + r3
                          ; SO=1: shift r2 by value in r4

; Barrel shifter emulation
ADDR r4, r5, r6, ASR r7  ; r4 = (r5 >> r7) + r6 (arithmetic)
\end{lstlisting}

\section{Shift Count}

The shift count is a 4-bit field, allowing shifts of 0--15 positions.

\begin{itemize}
	\item Shift count of 0 means no shift is performed
	\item Maximum shift count is 15
	\item Shift counts $\geq$ 16 would be meaningless for 16-bit values
\end{itemize}

\section{Status Flag Effects}

\subsection{Default Behavior}

When shift operations are used with ALU instructions, the status flags are \textbf{by default} updated based on the
\textbf{ALU operation result}, not the shift operation. For example, in \texttt{CMPI r2, \#1, LSL \#2}, the flags
reflect the comparison result, not the shift.

To update flags based on the shift operation instead, use the \texttt{[S]} status override modifier (see
Section~\ref{sec:status-override}), or use the \mnemonic{SHFT} meta-instruction (Chapter~\\ref{ch:meta-instructions}).

\subsection{Carry Flag}

For all shifts and rotates:
\begin{itemize}
	\item The last bit shifted out is placed in the carry flag
	\item For shifts of more than 1 position, only the final bit shifted out matters
	\item If shift count is 0, carry flag is not modified
\end{itemize}

\subsection{Zero Flag}

Set if the result after shifting is zero.

\subsection{Negative Flag}

Set if bit 15 of the result is 1 (result is negative when interpreted as signed).

\subsection{Overflow Flag}

\begin{itemize}
	\item For \textbf{ASL}: Set if the sign bit changes during the shift (signed overflow)
	\item For other shifts: Behavior is undefined; typically unchanged or cleared
\end{itemize}

\section{Common Use Cases}

\subsection{Multiplication by Constants}

\begin{lstlisting}
; Multiply by 2
ADDI r1, #0, LSL #1   ; r1 = (r1 << 1) = r1 * 2

; Multiply by 3
ADDR r1, r2, r2, LSL #1   ; r1 = (r2 << 1) + r2 = r2 * 3

; Multiply by 5
ADDR r1, r2, r2, LSL #2   ; r1 = (r2 << 2) + r2 = r2 * 5
\end{lstlisting}

\subsection{Division by Powers of 2}

\begin{lstlisting}
; Unsigned divide by 4
LOAD r1, r2        ; r1 = r2
ADDI r1, #0, LSR #2   ; r1 = (r1 >> 2) = r1 / 4 (unsigned)

; Signed divide by 8
LOAD r1, r2        ; r1 = r2
ADDI r1, #0, ASR #3   ; r1 = (r1 >> 3) = r1 / 8 (signed)
\end{lstlisting}

\subsection{Bit Field Extraction}

\begin{lstlisting}
; Extract bits 8-11 from r1
LOAD r2, r1        ; r2 = r1
ADDI r2, #0, LSR #8   ; Shift down
ANDI r2, #0x0F            ; Mask to 4 bits

; Extract and sign-extend bit 7
LOAD r2, r1        ; r2 = r1
ADDI r2, #0, LSL #8   ; Shift bit 7 to bit 15
ADDI r2, #0, ASR #8   ; Arithmetic shift to sign-extend
\end{lstlisting}

\subsection{Bit Manipulation}

\begin{lstlisting}
; Set bit N (where N is in r2)
LOAD r3, #1               ; r3 = 1
ADDI r3, #0, LSL r2       ; r3 = (r3 << r2) = 1 << N
ORRR r1, r3               ; r1 |= (1 << N)

; Clear bit N
LOAD r3, #1
ADDI r3, #0, LSL r2       ; r3 = (r3 << r2) = 1 << N
LOAD r4, #0xFFFF
XORR r3, r4, r3           ; r3 = 0xFFFF ^ (1 << N) = ~(1 << N)
ANDR r1, r1, r3           ; r1 = r1 & ~(1 << N)

; Test bit N
LOAD r3, #1
ADDI r3, #0, LSL r2       ; r3 = (r3 << r2) = 1 << N
TSAR r1, r3               ; Test r1 & (1 << N)
BRAN|!= bit_was_set       ; Branch if bit set
\end{lstlisting}

\section{Multi-Word Shifts}

For operations on values larger than 16 bits, shifts and rotates can be combined:

\subsection{32-bit Left Shift}

\begin{lstlisting}
; Shift 32-bit value in r1:r2 left by 1
; r1 = high word, r2 = low word
ADDI r2, #0, LSL #1   ; Shift low, MSB -> carry
ADDI r1, #0, RTL #1   ; Rotate high with carry
\end{lstlisting}

\subsection{32-bit Right Shift (Unsigned)}

\begin{lstlisting}
; Shift 32-bit value in r1:r2 right by 1 (unsigned)
ADDI r1, #0, LSR #1   ; Shift high, LSB -> carry
ADDI r2, #0, RTR #1   ; Rotate low with carry
\end{lstlisting}

\subsection{32-bit Right Shift (Signed)}

\begin{lstlisting}
; Shift 32-bit value in r1:r2 right by 1 (signed)
ADDI r1, #0, ASR #1   ; Arithmetic shift high
ADDI r2, #0, RTR #1   ; Rotate low with carry
\end{lstlisting}

\section{Performance Considerations}

\begin{itemize}
	\item All shift operations complete in the same number of cycles regardless of shift count
	\item Shifts can be performed "for free" as part of another instruction (no extra cycles)
	\item Using shifts for multiplication/division by powers of 2 is much faster than using a multiply/divide instruction (if one
	      existed)
	\item Barrel shifter implementation in hardware allows any shift count in constant time
\end{itemize}

\section{Limitations}

\begin{itemize}
	\item Maximum shift count is 15 (4-bit field)
	\item For shifts $>$ 15, multiple shift instructions must be used
	\item Rotates include the carry flag, so rotating by 16 does not equal original value
	\item Some shift types (e.g., reserved type 111) may have undefined behavior
\end{itemize}

\section{Status Flag Update Control}
\label{sec:status-override}

By default, ALU instructions with shift operations update the status register flags based on the \textbf{ALU operation
	result}, not the shift operation. However, the SIRC-1 provides manual control over which operation updates the flags.

\subsection{Status Override Syntax}

A status override modifier can be added immediately after an instruction mnemonic using square brackets:

\begin{table}[H]
	\centering
	\begin{tabular}{clp{8cm}}
		\toprule
		\textbf{Modifier} & \textbf{Meaning} & \textbf{Description}                    \\
		\midrule
		{[}A{]}           & ALU              & Update flags from ALU result (default)  \\
		{[}S{]}           & Shift            & Update flags from shift result, not ALU \\
		{[}N{]}           & None             & Do not update status flags at all       \\
		\bottomrule
	\end{tabular}
	\caption{Status Flag Override Modifiers}
	\label{tab:status-override}
\end{table}

\subsection{Examples}

\textbf{Default Behavior (ALU flags):}
\begin{lstlisting}
; Without override, flags reflect the ALU addition result
ADDI r2, #1, LSL #2           ; r2 = (r2 << 2) + 1
                              ; Flags: based on addition result
\end{lstlisting}

\textbf{Shift Flag Override:}
\begin{lstlisting}
; Update flags based on shift result instead of ALU
ADDI[S] r2, #1, LSL #2        ; r2 = (r2 << 2) + 1
                              ; Flags: based on (r2 << 2), not the +1

; Check if shifted value is zero
CMPI[S] r3, #0, LSR #4        ; Compare (r3 >> 4) with 0
                              ; Flags: based on shift, not comparison
\end{lstlisting}

\textbf{No Flag Update:}
\begin{lstlisting}
; Perform operation without affecting status flags
ADDI[N] r1, #5, LSL #1        ; r1 = (r1 << 1) + 5
                              ; Flags: unchanged

; Useful when preserving flags from previous operation
CMPI r4, r5                   ; Set flags based on comparison
ADDI[N] r6, #1                ; Increment r6 without changing flags
BRAN|== equal_branch          ; Branch using flags from CMPI
\end{lstlisting}

\subsection{Use Cases}

\subsubsection{Testing Shift Results}

When you need to know properties of a shifted value without performing a subsequent comparison:

\begin{lstlisting}
; Check if r1 << 3 would be negative
ADDI[S] r1, #0, LSL #3        ; r1 = r1 << 3, flags from shift
BRAN|NS overflow_detected     ; Branch if sign bit set
\end{lstlisting}

\subsubsection{Preserving Flags}

When performing operations that should not affect condition codes:

\begin{lstlisting}
; Test condition
CMPI r1, r2                   ; Compare r1 and r2

; Do some work without affecting flags
ADDI[N] r3, #1                ; Increment counter (flags unchanged)
LOAD[N] r4, (#0, a)+          ; Load next value (flags unchanged)

; Branch using original comparison flags
BRAN|>= r1_was_greater
\end{lstlisting}

\subsubsection{SHFT Meta-Instruction}

The \mnemonic{SHFT} meta-instruction (see Chapter~\ref{ch:meta-instructions}) uses the {[}S{]} modifier internally:

\begin{lstlisting}
SHFT r1, ASL #3               ; Expands to: ORRI[S] r1, #0, ASL #3
\end{lstlisting}

This provides a clean syntax for shift-only operations with flag updates.

\subsection{Assembler Syntax Notes}

\begin{itemize}
	\item The status override modifier must appear immediately after the instruction mnemonic with no spaces: \texttt{ADDI[S]}
	\item The modifier is optional; omitting it defaults to {[}A{]} (ALU flag updates)
	\item The override applies to the entire instruction, including any conditional execution
	\item Explicit {[}A{]} is rarely needed but can improve code readability
\end{itemize}