\chapter{Shift Operations}
\label{ch:shift-operations}

\section{Overview}

The SIRCULAR CPU supports powerful shift operations that can be applied to operands in many instructions. Shifts can
multiply or divide values by powers of 2, extract bit fields, or perform bit rotations.

Shift operations are encoded within Short Immediate and Register format instructions, allowing a value to be shifted
before being used in an ALU operationâ€”all within a single instruction.

\section{Shift Types}

\subsection{Shift Type Encoding}

\begin{table}[H]
	\centering
	\begin{tabular}{clcp{7cm}}
		\toprule
		\textbf{Code} & \textbf{Mnemonic} & \textbf{Type}          & \textbf{Description}             \\
		\midrule
		000           & --                & None                   & No shift performed               \\
		001           & LSL               & Logical Shift Left     & Shift left, fill with zeros      \\
		010           & LSR               & Logical Shift Right    & Shift right, fill with zeros     \\
		011           & ASL               & Arithmetic Shift Left  & Same as LSL (shifts in zeros)    \\
		100           & ASR               & Arithmetic Shift Right & Shift right, preserving sign bit \\
		101           & ROL               & Rotate Left            & Rotate left through carry        \\
		110           & ROR               & Rotate Right           & Rotate right through carry       \\
		111           & --                & Reserved               & Reserved for future use          \\
		\bottomrule
	\end{tabular}
	\caption{Shift Type Encoding}
	\label{tab:shift-encoding}
\end{table}

\section{Shift Type Details}

\subsection{Logical Shift Left (LSL)}

\textbf{Operation:} Shift bits to the left, filling vacated bits with zeros.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{17}
		\bitheader{0-15} \\
		\bitbox{1}{$\leftarrow$}
		\bitbox{15}{\small Shift Left}
		\bitbox{1}{0}
	\end{bytefield}
	\caption{Logical Shift Left}
\end{figure}

\begin{itemize}
	\item Bit 15 is shifted into the carry flag
	\item Bit 0 receives 0
	\item Equivalent to multiplying by $2^n$ where $n$ is the shift count
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Multiply by 4
ADDI r1, #0, r2, LSL #2  ; r1 = r2 * 4

; Set bit 10
ORRI r3, #1, LSL #10     ; r3 |= 0x0400
\end{lstlisting}

\subsection{Logical Shift Right (LSR)}

\textbf{Operation:} Shift bits to the right, filling vacated bits with zeros.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{17}
		\bitheader{0-15} \\
		\bitbox{1}{0}
		\bitbox{15}{\small Shift Right}
		\bitbox{1}{$\rightarrow$}
	\end{bytefield}
	\caption{Logical Shift Right}
\end{figure}

\begin{itemize}
	\item Bit 0 is shifted into the carry flag
	\item Bit 15 receives 0
	\item Equivalent to unsigned division by $2^n$
	\item Use for unsigned values only
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Divide unsigned value by 8
ADDI r1, #0, r2, LSR #3  ; r1 = r2 / 8 (unsigned)

; Extract upper byte
ADDR r3, r4, #0, LSR #8  ; r3 = r4 >> 8
\end{lstlisting}

\subsection{Arithmetic Shift Left (ASL)}

\textbf{Operation:} Identical to LSL. Shift bits to the left, filling with zeros.

\begin{itemize}
	\item Equivalent to signed multiplication by $2^n$
	\item Can cause signed overflow if sign bit changes
	\item Overflow flag is set if sign bit changes during shift
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Multiply signed value by 2
ADDI r1, #0, r2, ASL #1  ; r1 = r2 * 2 (signed)
\end{lstlisting}

\subsection{Arithmetic Shift Right (ASR)}

\textbf{Operation:} Shift bits to the right, preserving the sign bit (bit 15).

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{17}
		\bitheader{0-15} \\
		\bitbox{1}{$\curvearrowleft$}
		\bitbox{15}{\small Shift Right}
		\bitbox{1}{$\rightarrow$}
	\end{bytefield}
	\caption{Arithmetic Shift Right}
\end{figure}

\begin{itemize}
	\item Bit 0 is shifted into the carry flag
	\item Bit 15 (sign bit) is copied into bit 15 and bit 14
	\item Equivalent to signed division by $2^n$ (rounds toward negative infinity)
	\item Use for signed values only
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Divide signed value by 4
ADDI r1, #0, r2, ASR #2  ; r1 = r2 / 4 (signed)

; Average two signed values
ADDR r3, r4, r5
ADDR r3, r3, #0, ASR #1  ; r3 = (r4 + r5) / 2
\end{lstlisting}

\subsection{Rotate Left (ROL)}

\textbf{Operation:} Rotate bits to the left through the carry flag.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{18}
		\bitbox{1}{C}
		\bitheader{0-15} \\
		\bitbox{1}{$\curvearrowleft$}
		\bitbox{1}{$\leftarrow$}
		\bitbox{15}{\small Rotate Left}
		\bitbox{1}{$\curvearrowleft$}
	\end{bytefield}
	\caption{Rotate Left}
\end{figure}

\begin{itemize}
	\item Bit 15 moves into the carry flag
	\item Previous carry flag value moves into bit 0
	\item No data is lost
	\item Useful for multi-word shifts and bit manipulation
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Rotate r1 left by 1
ADDR r1, r1, #0, ROL #1

; Multi-word left shift (32-bit value in r1:r2)
ADDR r2, r2, #0, LSL #1  ; Shift low word, bit 15 -> carry
ADDR r1, r1, #0, ROL #1  ; Shift high word, carry -> bit 0
\end{lstlisting}

\subsection{Rotate Right (ROR)}

\textbf{Operation:} Rotate bits to the right through the carry flag.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.2em]{18}
		\bitheader{0-15}
		\bitbox{1}{C} \\
		\bitbox{1}{$\curvearrowright$}
		\bitbox{15}{\small Rotate Right}
		\bitbox{1}{$\rightarrow$}
		\bitbox{1}{$\curvearrowright$}
	\end{bytefield}
	\caption{Rotate Right}
\end{figure}

\begin{itemize}
	\item Bit 0 moves into the carry flag
	\item Previous carry flag value moves into bit 15
	\item No data is lost
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
; Rotate r1 right by 1
ADDR r1, r1, #0, ROR #1

; Check if bit 0 is set
ADDR r2, r1, #0, ROR #1  ; Bit 0 -> carry
; Now branch on carry to test bit 0
\end{lstlisting}

\section{Shift Operands}

The Shift Operand (SO) bit determines what value is shifted:

\begin{table}[H]
	\centering
	\begin{tabular}{clp{8cm}}
		\toprule
		\textbf{SO Bit} & \textbf{Mode}           & \textbf{Description}                                      \\
		\midrule
		0               & Shift Immediate/R3      & The immediate value or R3 register value is shifted       \\
		1               & Shift Count in Register & R3 contains the shift count; R2 is shifted by that amount \\
		\bottomrule
	\end{tabular}
	\caption{Shift Operand Modes}
	\label{tab:shift-operand}
\end{table}

\subsection{Mode 0: Shift the Value}

The value itself (immediate or register) is shifted before the ALU operation.

\begin{lstlisting}
; Add r2 * 4 to r1
ADDR r1, r2, r2, LSL #2  ; r1 = r2 + (r2 << 2) = r2 * 5
                          ; SO=0: r2 value is shifted

; Load with scaled offset
LOAD r1, (r2, a), LSL #1 ; EA = a + (r2 << 1)
                          ; SO=0: r2 value is shifted
\end{lstlisting}

\subsection{Mode 1: Shift by Register Count}

The shift count is taken from a register, allowing variable-length shifts.

\begin{lstlisting}
; Variable shift
; r3 contains shift amount
ADDR r1, r2, r3, LSL     ; r1 = r2 << r3
                          ; SO=1: shift r2 by r3's value

; Barrel shifter emulation
ADDR r4, r5, r6, ASR     ; r4 = r5 >> r6 (arithmetic)
\end{lstlisting}

\section{Shift Count}

The shift count is a 4-bit field, allowing shifts of 0--15 positions.

\begin{itemize}
	\item Shift count of 0 means no shift is performed
	\item Maximum shift count is 15
	\item Shift counts $\geq$ 16 would be meaningless for 16-bit values
\end{itemize}

\section{Status Flag Effects}

\subsection{Carry Flag}

For all shifts and rotates:
\begin{itemize}
	\item The last bit shifted out is placed in the carry flag
	\item For shifts of more than 1 position, only the final bit shifted out matters
	\item If shift count is 0, carry flag is not modified
\end{itemize}

\subsection{Zero Flag}

Set if the result after shifting is zero.

\subsection{Negative Flag}

Set if bit 15 of the result is 1 (result is negative when interpreted as signed).

\subsection{Overflow Flag}

\begin{itemize}
	\item For \textbf{ASL}: Set if the sign bit changes during the shift (signed overflow)
	\item For other shifts: Behavior is undefined; typically unchanged or cleared
\end{itemize}

\section{Common Use Cases}

\subsection{Multiplication by Constants}

\begin{lstlisting}
; Multiply by 2
ADDR r1, r2, r2, LSL #1   ; r1 = r2 * 2

; Multiply by 3
ADDR r1, r2, r2, LSL #1   ; r1 = r2 + (r2 * 2) = r2 * 3

; Multiply by 5
ADDR r1, r2, r2, LSL #2   ; r1 = r2 + (r2 * 4) = r2 * 5

; Multiply by 10
ADDR r1, r2, r2, LSL #2   ; r1 = r2 * 5
ADDR r1, r1, r1, LSL #1   ; r1 = r1 * 2 = r2 * 10
\end{lstlisting}

\subsection{Division by Powers of 2}

\begin{lstlisting}
; Unsigned divide by 4
ADDR r1, r2, #0, LSR #2   ; r1 = r2 / 4 (unsigned)

; Signed divide by 8
ADDR r1, r2, #0, ASR #3   ; r1 = r2 / 8 (signed)
\end{lstlisting}

\subsection{Bit Field Extraction}

\begin{lstlisting}
; Extract bits 8-11 from r1
ADDR r2, r1, #0, LSR #8   ; Shift down
ANDI r2, #0x0F            ; Mask to 4 bits

; Extract and sign-extend bit 7
ADDR r2, r1, #0, LSL #8   ; Shift bit 7 to bit 15
ADDR r2, r2, #0, ASR #8   ; Arithmetic shift to sign-extend
\end{lstlisting}

\subsection{Scaled Array Indexing}

\begin{lstlisting}
; Access array of 4-byte structures
; r2 = index, 'a' = base address
; Each element is 4 bytes, so multiply index by 4
LOAD r1, (r2, a), LSL #2  ; EA = a + (index * 4)

; Access array of 16-bit values
LOAD r3, (r4, a), LSL #1  ; EA = a + (index * 2)
\end{lstlisting}

\subsection{Bit Manipulation}

\begin{lstlisting}
; Set bit N (where N is in r2)
ADDI r3, #1               ; r3 = 1
ADDR r3, r3, r2, LSL      ; r3 = 1 << N
ORRR r1, r3               ; r1 |= (1 << N)

; Clear bit N
ADDI r3, #1
ADDR r3, r3, r2, LSL      ; r3 = 1 << N
XORI r3, #0xFFFF          ; r3 = ~(1 << N)
ANDR r1, r3               ; r1 &= ~(1 << N)

; Test bit N
ADDI r3, #1
ADDR r3, r3, r2, LSL      ; r3 = 1 << N
TSAR r1, r3               ; Test r1 & (1 << N)
BRAN|!= bit_was_set       ; Branch if bit set
\end{lstlisting}

\section{Multi-Word Shifts}

For operations on values larger than 16 bits, shifts and rotates can be combined:

\subsection{32-bit Left Shift}

\begin{lstlisting}
; Shift 32-bit value in r1:r2 left by 1
; r1 = high word, r2 = low word
ADDR r2, r2, #0, LSL #1   ; Shift low, MSB -> carry
ADDR r1, r1, #0, ROL #1   ; Rotate high with carry
\end{lstlisting}

\subsection{32-bit Right Shift (Unsigned)}

\begin{lstlisting}
; Shift 32-bit value in r1:r2 right by 1 (unsigned)
ADDR r1, r1, #0, LSR #1   ; Shift high, LSB -> carry
ADDR r2, r2, #0, ROR #1   ; Rotate low with carry
\end{lstlisting}

\subsection{32-bit Right Shift (Signed)}

\begin{lstlisting}
; Shift 32-bit value in r1:r2 right by 1 (signed)
ADDR r1, r1, #0, ASR #1   ; Arithmetic shift high
ADDR r2, r2, #0, ROR #1   ; Rotate low with carry
\end{lstlisting}

\section{Performance Considerations}

\begin{itemize}
	\item All shift operations complete in the same number of cycles regardless of shift count
	\item Shifts can be performed "for free" as part of another instruction (no extra cycles)
	\item Using shifts for multiplication/division by powers of 2 is much faster than using a multiply/divide instruction (if one
	      existed)
	\item Barrel shifter implementation in hardware allows any shift count in constant time
\end{itemize}

\section{Limitations}

\begin{itemize}
	\item Maximum shift count is 15 (4-bit field)
	\item For shifts $>$ 15, multiple shift instructions must be used
	\item Rotates include the carry flag, so rotating by 16 does not equal original value
	\item Some shift types (e.g., reserved type 111) may have undefined behavior
\end{itemize}
