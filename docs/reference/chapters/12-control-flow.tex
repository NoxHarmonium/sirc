\chapter{Control Flow Instructions}
\label{ch:control-flow}

\section{Overview}

Control flow instructions modify the program counter to change the execution flow. The SIRC-1 provides several types of
control flow operations:

\begin{itemize}
	\item \mnemonic{BRAN} -- Branch (unconditional or conditional jump)
	\item \mnemonic{LJMP} -- Long Jump (transfer address register to PC)
	\item \mnemonic{LJSR} -- Long Jump to Subroutine (with link)
	\item \mnemonic{BRSR} -- Branch to Subroutine (relative, with link)
	\item \mnemonic{LDEA} -- Load Effective Address (can be used for jumps)
\end{itemize}

All control flow instructions can be conditional, allowing efficient implementation of if-then-else and loop
constructs.

\section{Branch Instructions}

\begin{instructionbox}{BRAN -- Branch}
	\textbf{Opcodes:} 0x1A (Imm Displacement), 0x1B (Reg Displacement)

	\textbf{Syntax:}
	\begin{lstlisting}
BRAN (#disp, p)               ; PC = PC + disp
BRAN (rS, p)                  ; PC = PC + rS
BRAN|cond (#disp, p)          ; Conditional branch
\end{lstlisting}

	\textbf{Description:}

	Branches to a new location by adding a displacement to the program counter. The displacement can be an immediate value
	(for fixed jumps) or a register value (for computed jumps). Branches are typically PC-relative. \textbf{Examples:}
	\begin{lstlisting}
; Unconditional branch forward
BRAN (#20, p)                 ; Jump ahead 20 words

; Backward branch (loop)
loop:
    ; ... loop body ...
    BRAN|!= (#-16, p)         ; Jump back if not zero

; Conditional branch
CMPI r1, #10
BRAN|>= (#8, p)               ; Branch if r1 >= 10
\end{lstlisting}

\end{instructionbox}

\section{Long Jump}

\begin{instructionbox}{LJMP -- Long Jump}
	\textbf{Opcodes:} 0x18 (Imm Offset), 0x19 (Reg Offset)

	\textbf{Syntax:}
	\begin{lstlisting}
LJMP src                      ; PC = src
LJMP src, #offset             ; PC = src + offset
LJMP src, rS                  ; PC = src + rS
\end{lstlisting}

	\textbf{Description:}

	Jumps to an absolute address by transferring the contents of an address register to the program counter. This is a
	meta-instruction that assembles to \mnemonic{LDEA} with \reg{p} as the hardcoded destination. Unlike \mnemonic{BRAN}
	which uses PC-relative addressing, \mnemonic{LJMP} performs absolute jumps using address registers.

	The instruction supports optional immediate or register offsets. Note that shift operations cannot be applied to the
	displacement operand for this instruction.

	\textbf{Privilege:} Privileged instruction (like \mnemonic{LDEA}).

	\textbf{Examples:}
	\begin{lstlisting}
; Simple absolute jump
LOAD ah, #0x0040
LOAD al, #0x0000              ; a = 0x00400000
LJMP a                        ; Jump to 0x00400000

; Jump with immediate offset
LJMP a, #16                   ; Jump to a + 16

; Jump with register offset (jump table)
LOAD r1, #8                   ; Table index * 2
LJMP b, r1                    ; Jump to b + r1
\end{lstlisting}

\end{instructionbox}

\section{Subroutine Call Instructions}

\begin{instructionbox}{LJSR -- Long Jump to Subroutine}
	\textbf{Opcodes:} 0x1C (Imm), 0x1D (Reg)

	\textbf{Syntax:}
	\begin{lstlisting}
LJSR src                      ; l = PC; PC = src
LJSR src, #offset             ; l = PC; PC = src + offset
LJSR src, rS                  ; l = PC; PC = src + rS
\end{lstlisting}

	\textbf{Description:}

	Calls a subroutine by saving the return address to the link register (\reg{l}) and jumping to the target address. The
	return address can later be restored using \mnemonic{RETS}. Supports optional immediate or register offsets, similar to
	\mnemonic{LJMP}.

	\textbf{Examples:}
	\begin{lstlisting}
; Call function at address in 'a'
LOAD ah, #0x0040
LOAD al, #0x0000              ; a = 0x00400000
LJSR a                        ; Call 0x00400000

; Call with offset
LJSR a, #function_offset      ; Call a + offset

; Call with register displacement (function pointer table)
LOAD r1, #8
LJSR b, r1                    ; Call b + r1

; Return from subroutine
RETS                          ; Assembles to: LDEA p, (#0, l)
\end{lstlisting}

\end{instructionbox}

\section{Load Effective Address}

\begin{instructionbox}{LDEA -- Load Effective Address}
	\textbf{Opcodes:} 0x18 (Imm), 0x19 (Reg)

	\textbf{Syntax:}
	\begin{lstlisting}
LDEA dest, (#offset, src)     ; dest = src + offset
LDEA dest, (rS, src)          ; dest = src + rS
\end{lstlisting}

	\textbf{Description:}

	Computes an effective address and loads it into the destination address register pair. Can be used for pointer
	arithmetic or, when the destination is the program counter, as a jump instruction.

	\textbf{Examples:}
	\begin{lstlisting}
; Pointer arithmetic
LDEA a, (#16, a)              ; a = a + 16

; Computed jump
LDEA p, (r1, p)               ; PC = PC + r1 (jump table)

; Return from subroutine
LDEA p, (#0, l)               ; PC = l (RETS pseudo-instruction)
\end{lstlisting}

\end{instructionbox}

\section{Control Flow Patterns}

\subsection{If-Then-Else}
\begin{lstlisting}
; if (r1 > r2) { ... } else { ... }
CMPR r1, r2
BRAN|<= else_part
; Then part
; ...
BRAN (#end, p)
else_part:
; Else part
; ...
end:
\end{lstlisting}

\subsection{While Loop}
\begin{lstlisting}
; while (r1 > 0) { ... }
while_start:
    CMPI r1, #0
    BRAN|<= while_end
    ; Loop body
    ; ...
    BRAN (#while_start, p)
while_end:
\end{lstlisting}

\subsection{Switch/Jump Table}
\begin{lstlisting}
; Switch on r1 (0-3)
LOAD r2, r1                   ; r2 = r1
ADDI r2, #0, LSL #1           ; r2 = (r2 << 1) = r2 * 2 (word size)
LDEA p, (r2, p)               ; Jump via table

jump_table:
    DW case0 - jump_table
    DW case1 - jump_table
    DW case2 - jump_table
    DW case3 - jump_table
\end{lstlisting}

\textit{(Additional control flow details would follow)}
