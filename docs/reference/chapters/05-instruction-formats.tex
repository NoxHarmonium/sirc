\chapter{Instruction Formats}
\label{ch:instruction-formats}

\section{Overview}

All SIRCIS instructions are exactly 32 bits (4 bytes, or 2 words) in length. This fixed instruction size simplifies
instruction fetch and decode logic, though it may result in larger code size compared to variable-length instruction
sets.

The SIRC-1 supports three distinct instruction formats:

\begin{enumerate}
	\item Immediate
	\item Short Immediate (with Shift)
	\item Register
\end{enumerate}

Note: there are meta instructions that do not take any arguments (e.g. NOOP) but they are still assembled to by one of the three instruction formats. There is no "implied" instruction format supported by the CPU.

Each format is optimized for different types of operations and addressing modes.

\section{Format Overview}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{lp{9cm}}
		\toprule
		\textbf{Format} & \textbf{Typical Use}                                             \\
		\midrule
		Immediate       & Operations with a 16-bit constant value                          \\
		Short Immediate & Operations with an 8-bit constant and optional shift             \\
		Register        & Operations on multiple registers with optional shift             \\
		\bottomrule
	\end{tabular}
	\caption{Instruction Format Summary}
	\label{tab:format-summary}
\end{table}

\section{Common Fields}

All instruction formats share some common fields:

\begin{description}
	\item[Opcode (6 bits)] Identifies the operation to perform. With 6 bits, up to 64 distinct operations can be encoded.

	\item[Condition Flags (4 bits)] Specifies under what conditions the instruction should execute. See
	      Chapter~\ref{ch:condition-codes} for details.

	\item[Additional Flags (2 bits)] Used in some formats to specify address register pairs (a, p, s, l) or other modifiers.
\end{description}

\section{Immediate Format}

\subsection{Structure}

The immediate format encodes a full 16-bit immediate value within the instruction.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.25em]{32}
		\bitheader{0-31} \\
		\bitbox{6}{Opcode} &
		\bitbox{4}{Reg} &
		\bitbox{16}{Immediate Value} &
		\bitbox{2}{Addr} &
		\bitbox{4}{Cond}
	\end{bytefield}
	\caption{Immediate Instruction Format}
	\label{fig:immediate-format}
\end{figure}

\begin{description}
	\item[Opcode (bits 31--26)] 6-bit operation code
	\item[Register (bits 25--22)] 4-bit destination/source register identifier
	\item[Immediate (bits 21--6)] 16-bit signed or unsigned immediate value
	\item[Address Reg (bits 5--4)] 2-bit address register pair selector (for memory operations)
	      \begin{itemize}
		      \item 00 = l (link register)
		      \item 01 = a (address register)
		      \item 10 = s (stack pointer)
		      \item 11 = p (program counter)
	      \end{itemize}
	\item[Condition (bits 3--0)] 4-bit condition code
\end{description}

\subsection{Examples}

\begin{lstlisting}
ADDI r1, #100          ; r1 = r1 + 100
CMPI r2, #0x8000       ; Compare r2 with 0x8000
LOAD r3, (#16, a)      ; r3 = memory[a + 16]
STOR r4, (#-2, s)      ; memory[s - 2] = r4
\end{lstlisting}

\section{Short Immediate Format (with Shift)}

\subsection{Structure}

The short immediate format sacrifices immediate value width to include shift information, allowing for more powerful
single-instruction operations.

Only supported for ALU instructions - cannot be used with any of the branching, or load/store instructions.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=1.25em]{32}
		\bitheader{0-31} \\
		\bitbox{6}{Op} &
		\bitbox{4}{Reg} &
		\bitbox{8}{Imm} &
		\bitbox{1}{SO} &
		\bitbox{3}{ST} &
		\bitbox{4}{SV} &
		\bitbox{2}{Addr} &
		\bitbox{4}{Cond}
	\end{bytefield}
	\caption{Short Immediate with Shift Format}
	\label{fig:short-imm-format}
\end{figure}

\begin{description}
	\item[Opcode (bits 31--26)] 6-bit operation code
	\item[Register (bits 25--22)] 4-bit destination/source register identifier
	\item[Immediate (bits 21--14)] 8-bit signed or unsigned immediate value
	\item[Shift Operand (bit 13)] 0 = Shift Value is shift count, 1 = Shift value is register
	\item[Shift Type (bits 12--10)] Type of shift operation (LSL, LSR, ASL, ASR, ROL, ROR)
	\item[Shift Value (bits 9--6)] Shift amount (or register containing shift amount)
	\item[Address Reg (bits 5--4)] 2-bit address register pair selector
	\item[Condition (bits 3--0)] 4-bit condition code
\end{description}

\subsection{Shift Types}

% TODO : Both short immediate and register instruction sets have shift types, should this table be in its own section?
% TODO: Link to the detailed section on shifting?

\begin{table}[H]
	\centering
	\begin{tabular}{clc}
		\toprule
		\textbf{Code} & \textbf{Type}          & \textbf{Mnemonic} \\
		\midrule
		000           & None (no shift)        & --                \\
		001           & Logical Shift Left     & LSL               \\
		010           & Logical Shift Right    & LSR               \\
		011           & Arithmetic Shift Left  & ASL               \\
		100           & Arithmetic Shift Right & ASR               \\
		101           & Rotate Left            & ROL               \\
		110           & Rotate Right           & ROR               \\
		111           & Reserved               & --                \\
		\bottomrule
	\end{tabular}
	\caption{Shift Type Encoding}
	\label{tab:shift-types}
\end{table}

\subsection{Examples}

\begin{lstlisting}

; r1 = (r1 << 3) + 2
ADDI r1, #2, LSL #3

\end{lstlisting}

\section{Register Format}

\subsection{Structure}

The register format allows operations on up to three registers with optional shift.

\begin{figure}[H]
	\centering
	\begin{bytefield}[bitwidth=0.75em]{32}
		\bitheader{0-31} \\
		\bitbox{6}{Op} &
		\bitbox{4}{R1} &
		\bitbox{4}{R2} &
		\bitbox{4}{R3} &
		\bitbox{1}{SO} &
		\bitbox{3}{ST} &
		\bitbox{4}{SV} &
		\bitbox{2}{Addr} &
		\bitbox{4}{Cond}
	\end{bytefield}
	\caption{Register Instruction Format}
	\label{fig:register-format}
\end{figure}

\begin{description}
	\item[Opcode (bits 31--26)] 6-bit operation code
	\item[Register 1 (bits 25--22)] 4-bit destination register
	\item[Register 2 (bits 21--18)] 4-bit source A register
	\item[Register 3 (bits 17--14)] 4-bit source B register
	\item[Shift Operand (bit 13)] 0 = Shift Value is shift count, 1 = Shift value is register
	\item[Shift Type (bits 12--10)] Type of shift operation (LSL, LSR, ASL, ASR, ROL, ROR)
	\item[Shift Value (bits 9--6)] Shift amount (or register containing shift amount)
	\item[Address Reg (bits 5--4)] 2-bit address register pair selector
	\item[Condition (bits 3--0)] Condition code
\end{description}

\subsection{Register Operand Semantics}

For most three-operand instructions:
\begin{itemize}
	\item R1 = Destination
	\item R2 = First source operand
	\item R3 = Second source operand (optional)
\end{itemize}

If R3 is zero or not specified, instructions use R1 as both destination and first source operand:

\begin{lstlisting}
ADDR r1, r2, r3  ; r1 = r2 + r3
ADDR r1, r2      ; r1 = r1 + r2 (R3 implicitly = R1)
\end{lstlisting}

\subsection{Examples}

\begin{lstlisting}
; Add two registers
ADDR r1, r2, r3         ; r1 = r2 + r3

; Add with shift
ADDR r1, r2, r3, LSL #2 ; r1 = (r2 << 2) + r3

; Load using register offset
LOAD r1, (r2, a)        ; r1 = memory[a + r2]

; Store with post-increment
STOR r1, (r2, s)+       ; memory[s + r2] = r1; s = s + 1
\end{lstlisting}

\section{Opcode Encoding Patterns}

The SIRCIS instruction set uses systematic opcode patterns to simplify decoding:

\subsection{ALU Instructions}

\begin{itemize}
	\item \textbf{0x0\_}: Immediate operand, save result
	\item \textbf{0x1\_}: Memory operations
	\item \textbf{0x2\_}: Short immediate with shift, save result
	\item \textbf{0x3\_}: Register operand, save result
\end{itemize}

\subsection{Test vs. Save}

Many ALU operations have both a "save result" and "test only" variant:

\begin{itemize}
	\item \textbf{+0x0}: Save result to destination
	\item \textbf{+0x8}: Test only (update flags, don't save result)
\end{itemize}

For example:
\begin{itemize}
	\item \opcode{04}: \mnemonic{ANDI} -- AND immediate, save result
	\item \opcode{0C}: \mnemonic{TSAI} -- Test AND immediate (don't save result)
\end{itemize}

\section{Instruction Fetch and Alignment}

\subsection{Fetch Process}

Since instructions are 32 bits and the data bus is 16 bits wide, each instruction requires two fetch cycles:

\begin{enumerate}
	\item Fetch high word (bits 31--16) from address in PC
	\item Increment PC by 2
	\item Fetch low word (bits 15--0) from address in PC
	\item Increment PC by 2
\end{enumerate}

\subsection{Alignment Requirements}

Instructions must be aligned on 4-byte boundaries. The low word of the program counter (\reg{pl}) must always be even,
and instructions must not span across 4-byte boundaries.

Attempting to fetch an instruction from an unaligned address (odd address or not on 4-byte boundary) will trigger an
alignment fault exception.

\section{Format Selection Guidelines}

When writing assembly code, the assembler automatically selects the appropriate format based on operands:

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{lll}
		\toprule
		\textbf{Assembly}               & \textbf{Format Used} & \textbf{Notes}          \\
		\midrule
		\texttt{ADDI r1, \#1000}        & Immediate            & Full 16-bit immediate   \\
		\texttt{ADDI r1, \#10, LSL \#2} & Short Immediate      & 8-bit immediate + shift \\
		\texttt{ADDR r1, r2, r3}        & Register             & Three register operands \\
		\texttt{NOOP}                   & Implied              & No operands             \\
		\bottomrule
	\end{tabular}
	\caption{Format Selection Examples}
	\label{tab:format-selection}
\end{table}

The choice of format affects instruction encoding but is generally transparent to the programmer, as the assembler
handles the details.
