\chapter{Control Flow Instructions}
\label{ch:control-flow}

\section{Overview}

Control flow instructions modify the program counter to change the execution flow. The SIRCULAR provides several types
of control flow operations:

\begin{itemize}
	\item \mnemonic{BRAN} -- Branch (unconditional or conditional jump)
	\item \mnemonic{LJSR} -- Long Jump to Subroutine (with link)
	\item \mnemonic{BRSR} -- Branch to Subroutine (relative, with link)
	\item \mnemonic{LDEA} -- Load Effective Address (can be used for jumps)
\end{itemize}

All control flow instructions can be conditional, allowing efficient implementation of if-then-else and loop
constructs.

\section{Branch Instructions}

\begin{instructionbox}{BRAN -- Branch}
	\textbf{Opcodes:} 0x1A (Imm Displacement), 0x1B (Reg Displacement)

	\textbf{Syntax:}
	\begin{lstlisting}
BRAN (#disp, p)               ; PC = PC + disp
BRAN (rS, p)                  ; PC = PC + rS
BRAN|cond (#disp, p)          ; Conditional branch
\end{lstlisting}

	\textbf{Description:}

	Branches to a new location by adding a displacement to the program counter. The displacement can be an immediate value
	(for fixed jumps) or a register value (for computed jumps). Branches are typically PC-relative.

	\textbf{Examples:}
	\begin{lstlisting}
; Unconditional branch forward
BRAN (#20, p)                 ; Jump ahead 20 bytes

; Backward branch (loop)
loop:
    ; ... loop body ...
    BRAN|!= (#-16, p)         ; Jump back if not zero

; Conditional branch
CMPI r1, #10
BRAN|>= (#8, p)               ; Branch if r1 >= 10
\end{lstlisting}

\end{instructionbox}

\section{Subroutine Call Instructions}

\begin{instructionbox}{LJSR -- Long Jump to Subroutine}
	\textbf{Opcodes:} 0x1C (Imm), 0x1D (Reg)

	\textbf{Syntax:}
	\begin{lstlisting}
LJSR (#addr, a)               ; l = PC; PC = a + addr
LJSR (#addr, p)               ; l = PC; PC = PC + addr (rel call)
\end{lstlisting}

	\textbf{Description:}

	Calls a subroutine by saving the return address to the link register (\reg{l}) and jumping to the target address. The
	return address can later be restored using \mnemonic{RETS}.

	\textbf{Examples:}
	\begin{lstlisting}
; Call function at address in 'a'
LJSR (#0, a)

; PC-relative call
LJSR (#function_offset, p)

; Return from subroutine
RETS                          ; Assembles to: LDEA p, (#0, l)
\end{lstlisting}

\end{instructionbox}

\section{Load Effective Address}

\begin{instructionbox}{LDEA -- Load Effective Address}
	\textbf{Opcodes:} 0x18 (Imm), 0x19 (Reg)

	\textbf{Syntax:}
	\begin{lstlisting}
LDEA dest, (#offset, src)     ; dest = src + offset
LDEA dest, (rS, src)          ; dest = src + rS
\end{lstlisting}

	\textbf{Description:}

	Computes an effective address and loads it into the destination address register pair. Can be used for pointer
	arithmetic or, when the destination is the program counter, as a jump instruction.

	\textbf{Examples:}
	\begin{lstlisting}
; Pointer arithmetic
LDEA a, (#16, a)              ; a = a + 16

; Computed jump
LDEA p, (r1, p)               ; PC = PC + r1 (jump table)

; Return from subroutine
LDEA p, (#0, l)               ; PC = l (RETS pseudo-instruction)
\end{lstlisting}

\end{instructionbox}

\section{Control Flow Patterns}

\subsection{If-Then-Else}
\begin{lstlisting}
; if (r1 > r2) { ... } else { ... }
CMPR r1, r2
BRAN|<= else_part
; Then part
; ...
BRAN (#end, p)
else_part:
; Else part
; ...
end:
\end{lstlisting}

\subsection{While Loop}
\begin{lstlisting}
; while (r1 > 0) { ... }
while_start:
    CMPI r1, #0
    BRAN|<= while_end
    ; Loop body
    ; ...
    BRAN (#while_start, p)
while_end:
\end{lstlisting}

\subsection{Switch/Jump Table}
\begin{lstlisting}
; Switch on r1 (0-3)
ADDR r2, r1, r1, LSL #1       ; r2 = r1 * 2 (word size)
LDEA p, (r2, p)               ; Jump via table

jump_table:
    DW case0 - jump_table
    DW case1 - jump_table
    DW case2 - jump_table
    DW case3 - jump_table
\end{lstlisting}

\textit{(Additional control flow details would follow)}
